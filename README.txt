								"Lesch_OS"
*Простая учебная операционная система.
Операционная система работает с протоколами TCP/IP(и с несколькими протоколами прикладного уровня), файловой системой ext2, пользовательскими приложениями в  мультипоточном режиме(процессы тоже создает). Тестировалась, отлаживалась и запускалась только в Bochs. "Простая" и "учебная" в первую очередь из-за старого железа(драйверов для него), менеджеров выделения памяти и потоков(просто выбырает "следующий" из списка). "Спящие" потоки из списка убираются), в принципе, если их прокачать, то будет очень неплохо, хотя и так всё работает. Загружается с дискеты 1,44 Mb.

==================================================================================================================
$Загрузчик // состоит из: boot.asm, kern_boot.asm, kernel.asm.
	#(boot.asm)Bios загружает код с нашей дискеты в RAM по адресу 0x7C00. Мы устанавливаем стек 
->вызываем 3функцию 10прерывания(чистим экран и устанавливаем text mode 80x25)->выводим на экран id диска через функцию "BIOS_printf"
-> копируем (читаем)код с ROM(начиная со 2сектора и всего читаем 61 сектор) в RAM по адресу "kernel_buffer" 
-> устанавливаем data сегмент и делаем дальний переход на "kernel_buffer".
	#(kern_boot.asm)делаем небольшую проверку и если не прошли ее, то выводим сообщение и зацикливаемся 
-> создаем карту памяти (размером в 500b) и данные о ней в структуру mboot_struct, которую потом передадим в ядро
-> переходим в защищённый режим(открываем линию "A20->отключаем не/маскируемые прерывания->загружаем адрес gdt_str(структура с адресом gdt и ее размером)->yтанавливаем бит в cr0->делаем дальний переход на 0x08:Kern_32)
->устанавливаем сегментные регистры в 0x10->выводим сообщение 
->выгружаем основной код(оставшийся) ядра из ROM в RAM по адрессу 2mb по частям через буффер"kernel_buffer", переключаясь из защищённого режима в рельный режим
->грузим адрес структуры "mboot_struct" в ebx, прыгаем в ядро (KERN_OFFSET(0x2mb)), в функцию _go в файле kernel.asm
	#(kernel.asm)устанавливаем esp на 2mb - 4(чуть ниже чем мы находимся сейчас)->кладём в стек адрес стека(esp) и "mboot_struct" (ebx)->прыгаем в основную функцию ядра"_kernel" в файле main.c
->выходя из ядра, переходим в спящий режим(hlt) и защикливаемся.
==================================================================================================================
$Таблица дескрипторов и прерываний В ЯДРЕ(не та, что была в загрузчике) // состоит из: table_descript.c, tab_descr_asm.asm, isr_asm.asm, isr.c, isr_handl, syscall.c
	#(tables_descript.c)формируем gdt и tss->загружаем структуры gdt и tss в специальные регистры(asm:lgdt/ltr)
->через порты PIC контроллера переназначаем номера прерываний
->формируем таблицу прерываний->загружаем структуру idt в специальный регистр(asm:lidt)
->регистрируем обработчики прерываний(пишем адреса функций в массив (индекс == номер прервыния))
->регистрируем обработчик системных вызовов(регистрируем как обработчик 0x30 прерывания)
==================================================================================================================
$Память // состоит из: memory.c
	#(memory.c)перебираем карту памяти по блокам из "mboot_struct" и записываем в глобальную переменную "size_phymemory" размер всей памяти в байтах "check_memory_map(memory_map_s *mmap_addr, u32int len)"
->в "init_memory_manager()" включаем страничную адресацию памяти "on_page_mode()"(создаём директорию таблиц(таблицу таблиц) по физическому и виртуальному адресу(5mb), а сами таблицы страниц располагаем сразу за директорией таблиц->отображаем физическую память на виртуальную с 0x00 по 0x1200000(физическая == виртуальная)->пишем физический адрес директории(5mb) в cr3 и немножко меняем cr0
->перебираем карту памяти и помечаем свободные блоки с адресом больше 1mb как свободные с помощью функции "free_phys_pages(physaddr base, u32int count)" и устанавливаем всю доступную память в переменную "memory_size"
->настраиваем кучу ядра(отображаем страницы для служебной информации кучи "phys2virt()"->отображаем страницы "phys2virt()" под кучу ядра(которые будем выделять такими функциями как:kmalloc(), kcalloc()...)
->заполняем структуру "heap_s" ядра.

	(ниже все адреса виртуальные, хотя должны соответствовать физическим)
*код ядра распологается по адресу с 0x200000 по 0x4FFFFF
*директория таблиц и таблицы страниц по адресу 0х500000 - 0х8FFFFF
*размер кучи ядра = 0x2000000
*размер памяти для информации об объектах кучи(оно же"отображаем страницы для служебной информации кучи "phys2virt()"") = 0x400000
*служебная информация о куче ядра располагается по адресу 0x1000000
*адрес начала кучи ядра располагается по адресу 0x7FFFFFFF - 2000000
==================================================================================================================
$Процессы и потоки // состоит из: schedul.c, process.c, shell.c, elf_loader.c, switch_task.asm, user.asm
	#(schedul.c) in "init_task_manager()" запрещаем прерывания и переключения между потоками функцией "stop"(просто повышает счётчик семафора "multi_task")
->создаем списки: proc_list, thread_list, thread_wait, tty16_list(для работы с графическим интерфейсом/вывод текста), msg_list, mpfile_list(список разделяемой памяти (что то вроде именнованных каналов))
->настраиваем USER HEAP в ядре(тображаем страницы для служебной информации кучи "phys2virt()"->отображаем страницы "phys2virt()" под USER HEAP в ядре(которые будем выделять такими функциями как:umalloc(), ucalloc()...)
->заполняем структуру "heap_s" USER HEAP в ядре
->создаём процесс и поток ядра ->добавляем их в соответствующие списки(proc_list/thread_list)
->разрешаем переключения между потоками функцией "start()" (уменьшает счётчик семафора "multi_task") и разрешаем 
прерывания(маскируемые)
*служебная информация о блоках USER HEAP всегда располагается по адресу 0x80000000
*выделяемая память под кучу USER HEAP располагается по адресу 0x80010000
*размер для служебной информации о блоках USER HEAP = 0x10000
*размер для памяти под кучу USER HEAP = 0x100000
------------------------------------------------------------------------------------------------------------------
@Создание исполняемых процессов:
	#(process.c)вызываем функцию "exec_proc(u8int *name, bool kern, u8int *cmd_line)"->загружаем с диска elf файл по его имени и заполняем структуру "elf_sections_s"(функция "elf_load(name)")
->выделяем из ядра свободные страницы и отображаем физический адрес на нужный(берем из "elf_sections_s") 
виртуальный адрес 
->создаем копию директории таблиц процесса ядра->помечаем в директории дескрипторы таблиц, отвечающие за USER_HEAP адрес кода приложения, как NO PRESENT(0 bit в 0)
->создаём процесс и поток
->формируем стек нового потока
->затем, когда ядро переключилось на наш новый поток, вызывается из стека(в него ранее мы засунули адрес на функцию "elf_start" и нужные параметры)функция elf_start"
->читаем код приложения из ROM в нужные(указаны в "elf_sections_s") виртульные адреса
->формируем user stack(до этого мы формировали стек потока в режиме ядра, а сейчас мы готовим новый стек для переключения из kernel mode в user mode
->заполняем структуру heap_s для USER_HEAP
->переходим в user mode, вызывая функцию "switch_user_mode()" передав параметры:точка входа в программу и наш новый стек
------------------------------------------------------------------------------------------------------------------
@Shell:
	#(shell.c)фукцией "shell_init(void)" мы блокируем маскируемые прерывания->запрещаем переключение между потоками(функция"stop()")->создаем процесс и поток(функция "proc_create", которая работает почти также как "exec_proc())
->выделяем из ядра свободные страницы и отображаем физический адрес на нужный(0x08049000) виртуальный адрес 
->аналогично делаем для стека приложения, только виртульный адрес другой(SHELL_VADDR(0x08049000) + размер кода приложения)
->формируем стек потока(кладем в него адрес нашего нового процесса, адрес на функцию "shell_start" и флаги
->разрешаем переключение между потоками и маскируемые прерывания
->выходим из функции "shell_init(void)" и ждем переключения на наш новый поток и процесс
->входим в функцию "shell_start"
->формируем user stack(до этого мы формировали стек потока в режиме ядра, а сейчас мы готовим новый стек для переключения из kernel mode в user mode
->заполняем структуру heap_s для USER_HEAP
->копируем код приложения из RAM в RAM, но на нужный виртуальный адрес(0x08049000)
->переходим в user mode, вызывая функцию "switch_user_mode()" передав параметры:точка входа в программу и наш новый стек

*приложение shell перехватывает через системный вызов нажатия клавиатуры, кладет значения клавиш(системный вызов сразу их переводит в asc2) в буффер, если будет клвавиша '\n', то вызывается системный вызов"shell_handler(u8int *shell_buff)". 
*В shell_handler():
->запрещаем переключение между процессами
->создаем новый буффер из кучи ядра(для того, чтобы передать параметры в другой процесс) и копируем в него данные из входного буффера("shell_buff")->вызывает функцию "exec_proc" c нужным флагом.
Если в shell_buff будет "exit", то !!!!процесс разрушается функцией "proc_destroy()" ЭТОЙ функцией завершается любой процесс!!!!!!
-> освобождаем ранее созданный буффер из кучи ядра функцией "kfree"
->разрешаем переключение между процессами и выходим
==================================================================================================================
$IPC // состоит из: ipc.c, socket.c 
	#(ipc.c)вызывая функцию (обычно как системный вызов) "mpfile_set(u8int *name, u32int *vaddr)", мы создаём структуру "mpfile_s"->добавляем ее в список(mpfile_list)->заполняем поля "name","pid_src"(id текущего процесса) и paddr(физический адрес входного параметра"vaddr")->выходим.
 !!! отображаемую память НУЖНО ВЫДЕЛЯТЬ ВЫРОВНЕННУЮ на одну страницу(0x1000bytes) функцией "umalloc_align", естественно через syscall!!!
->из другого процесса вызываем функцию(syscall) "mpfile_get(u8int *name, u32int *vaddr)"->ищем в списке"mpfile_list" структуру"mpfile_s" с name == входному параметру"name"-> если нашли, то отображаем на нужный виртуальный адрес(это входной параметр"vaddr") физический адрес из поля"*mpfie_s->paddr"
->готово!->выходим.

	#(socket.c)вызывая функцию "socket(u8int space_addr, u8int sock_type, u8int protocol)", мы ищем в массиве "socket_pool" свободный сокет и заполняем его поля(из интересного: в поле"socket.thread" заносим виртуальный адрес текущего потока)->если успешно, то возвращаем порядковый номер сокета в массиве(id сокета), иначе return 0 (согласен, функция может вернуть 0 и в случае успеха(если индекс в массиве == 0, но так надо);
->вызывая фукцию "sock_listen(u16int id, u16int max_ps)", мы проверяем существует ли уже в ядре порт(binded или нет), который мы указали в качестве источника в сокете с нужным id(входной параметр) и если не сущетсвует, то резервируем. Зарезервированные порты заносятся в массив "ports_binded" как часть структуры "bind_port_s"(в net.h).
->sock_close(u16int id)- очищаем сокет в массиве"socket_pool", и структуру порта в массиве "ports_binded".
->sock_bind(u16int id, void *ip_src, u16int port_src)- просто заносим дополнительные параметры в сокет(немного бесполезная функция).
->sock_connect(u16int id, void *ip_src, u16int port_src, void *ip_dst, u16int port_dst) - устанавливаем соединение
(отправляем запрос на соединение нужному узлу).
->sock_accept(u16int id) - ждёт в цикле подключения к нужному порту (вроде не использовал)
->sock_recv(socket_s *sock, u8int *recv_buff) - добавляет в сокет(sock) буффер(recv_buff) для приема байт и отправляет поток в режим ожидания"sleep" функцией"slp_thrd", когда TCP менеджер загрузит байты в recv_buff(переключает cr3 на нужную директорию таблиц страниц "socket->thread->proc->page_dir" копирует байты и возращает cr3 в прежнее состояние) функция вернёт количество принятых байт.
->sock_send(socket_s *sock, u8int *data, u32int size, u8int flag) - копирует данные из data в созданный из кучи ядра буффер, отправляет их как tcp пакет через функцию "tcp_xmit" с нужными флагами -> возвращает количество отправленных байт.
->ssock_send(socket_s *sock, u8int flags) - схема работы идентична sock_send(), просто нужно вручную заполнить поля "sock->send_bytes"(количество байт, которые нужно отправить) и "sock->buf_send"(буффер с данными, которые нужно отправить). ИСПОЛЬЗУЕТСЯ ДЛЯ SYSCALL, из-за нехватки регистров процессора для передачи параметров.

	#(msg.c) есть ещё "сообщения", НО они не тестировались и недописаны!!!!!!!(в коде нигде не используются).
==================================================================================================================
$NET // состоит из: net.c, rtl8029.c, socket.c
	#(net.c)Получение пакета: срабатывает прерывание и работает драйвер(rtl8029.c) в текущем потоке->из драйвера сетевой карты(rtl8029.c) получаем буффер и его размер в функцию "Ethernet_Recv(ether_s *eth, u32int len)" 
->передаём его в "Arp_Recv(arp_s *arp_pack, u32int len)" или в "Ip_Recv(ip_s *pack, u32int len)" (параметр "len" это размер пакета из тогоже буффера без размера заголовка ethernet, data - тот же буффер из драйвера, но без заголовка ethernet)
->из функции "Ip_Recv" передаём пакет в "Udp_Recv(ip_s *ip, u32int len)" либо в "Tcp_Recv(ip_s *ip, u32int len)"
ВНИМАНИЕ!!! передаем пакет с заголовком "ip_s", НО длинна считается без него!!!
->в функциях "Udp_Recv()" и "Tcp_Recv()" идёт поиск нужного сокета и далее. Когда дело доходит до отправки пакета в буффер приложения, то вызываются функции "udp_to_app" и "tcp_to_app", которые, чтобы скопировать принятый пакет в буффер приложения, переключают cr3 на директорию таблиц нужного процесса(socket->thread->proc->page_dir)->копируют->переключают cr3 обратно.

	Отправка пакета: вызываем sock_send()/ssock_send()(Работают только для TCP) и в ней создаём из кучи ядра новый буффер, в который копирует отправляемые данные и передает буффер на следующий уровень интернет протоколов.
!!!На каждом новом уровне создаётся новый буффер и в него копируются данные (с учетом смещения нового заголовка пакета), да, лучше переписать без создания новых буфферов, сразу выделяя нужный размер буффера с учетом длины всех заголовков протоколов.

	*Также реализованы протоколы: Tftp, Ftp, Dhcp(с ним что-то не все в порядке)
==================================================================================================================
$Файловая система // состоит из: vfs.c, ext2.c, ata.c
	виртуальная вайловая система(vfs.c) - интерфейс для работы с ext2.c. ata.c - драйвер для общения с hd.

==================================================================================================================
$Драйвера // pci.c, rtl8029.c rtl8139.c(не тестировался), ata.c, keyboard.c, timer.c, bios.c(переход в реальный режим и вызов нужных функций биос), vesa.c 





















